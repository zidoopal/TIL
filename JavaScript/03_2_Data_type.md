
> 데이터 타입(Data types) / 데이터 타입 간 차이점, 그 차이가 발생하는 원인 - (feat. 메모리관점)<br>

## ✍ 자바스크립트 데이터 타입
**JS에서 데이터타입은 크게 두가지로 분류된다.**
+ 기본형 (Primitive Type)
  + Number
  + String
  + Boolean
  + null
  + undefined
  + Symbol (ES6 추가)
  <br>
  
+ 참조형 (Reference Type)
  + Object
    + Array
    + Function
    + RegExp
    + Set / WeakSet (ES6)
    + Map / WeakMap (ES6)
    
    
>🤔<br>
❔ 이 데이터 타입들을 구분하는 이유는 무엇?<br>
>❔ 데이터 타입들에는 어떠한 차이가 있는가?<br>

***
> 실제 JS 메모리 구조는 아래와 같다.
>
|스택 메모리|힙 메모리|
|---|---|
|변수 / 기본형 데이터|참조형 데이터|
|정적 할당|동적 할당|
>
하지만 본 내용에서 stack / heap 메모리의 구조에 대한 깊은 설명은 생략- <br>
통틀어서 전체를 메모리라고 표현 하겠음.<br>
최대한 단순화 시켜 추상화 시킨 메모리에 대해 흐름을 파악 하는데에 중점을 둘 것<br>

***

## ✔ 기본형(Primitive Type) 데이터 할당의 순서

+ **변수 선언**
  + 변수 선언 시, 컴퓨터에서는 메모리 안에 데이터가 담길 공간을 확보한다.<br>
  확보한 공간의 이름에 식별자 a 지정.<br>
![](https://velog.velcdn.com/images/doopal2/post/54a249e5-6e8e-46b6-8c45-c35c11bd4015/image.png)

+ **a = '두팔' 할당**
  + 변수에 값 할당 시, 비어있는 다른 메모리 공간에 '두팔'이라는 값을 저장한다.<br>
![](https://velog.velcdn.com/images/doopal2/post/01786bf7-523a-4def-abbc-64f1bb3533ee/image.png)
  
  + a가 어디에 있는지 검색 후, a의 값에 '두팔'이 들어있는 메모리의 주소를 입력한다.<br>
![](https://velog.velcdn.com/images/doopal2/post/0ac933c6-b855-4131-9d45-eda4f0228ada/image.png)

+ **a = '지두팔' 재할당**
  + 변수에 값 재할당 시, 기존에 들어있던 메모리의 값을 재할당 하는 값으로 바꾸는 것 ❌<br>
  새로운 임의의 공간에 재할당된 값을 넣고 다시 a 검색 ▶ '지두팔'의 주소값으로 값을 변경.<br>
![](https://velog.velcdn.com/images/doopal2/post/d3f4ca17-a5ef-44b3-871b-721d628f42ea/image.png)

> 💡 **기본형에서는 데이터를 바꿀 때, 가리키고 있는 주소를 직접 바꿔놓는다.**



***

## ✔ 참조형(Reference Type) 데이터 할당의 순서
+ **변수 obj 선언**
![](https://velog.velcdn.com/images/doopal2/post/5e732dfb-bc0f-45c8-bf42-c6ef450e1404/image.png)

>💣 여기서,  obj = {a: 123, b: '두팔',}; 값을 메모리에 넣으려고 보니,<br>
객체 안에 프로퍼티가 있고 - <br>
프로퍼티 안에 각각의 값이 하나씩있음.  **현재 총 2개의 데이터가 필요한 상황**<br>
but, **메모리 구조 공간 하나에는 값이 하나씩 밖에 못들어감**<br>
>
so, **메모리 할당 과정을 1단계 더 거쳐야 함.**<br>

+ **값 할당**
![](https://velog.velcdn.com/images/doopal2/post/5e21b663-e33b-49f2-9e99-79385a286987/image.png)<br>
1. 각각의 프로퍼티의 이름과 값을 넣어 줄 공간을 충분히 확보해 준 후 (그림에서는 @8123 ~)<br>
6001번에 그 공간의 주솟값 범위 넣어줌<br>
2. 8123~ 번 메모리에 각 프로퍼티의 이름을 지정해줌.<br>
6002, 6003 번에 각각 프로퍼티의 값 데이터를 넣어주고<br>
@8123, @8124 값에 해당 주솟값 입력 <br>
3. obj 값에 '전부 이 객체의 프로퍼티다' 라고 지정해둔 프로퍼티의 주솟값 기재되어있는<br>
@6001 주솟값 넣어주기. <br>
<br>

+ **값 재할당**
![](https://velog.velcdn.com/images/doopal2/post/e1a85b8a-91eb-44ae-96cf-db900b20bcdb/image.png)<br>
1. 재할당 된 456을 또 임의의 메모리 공간 (그림에서는 @6004)에 값을 생성해줌 ▶obj.a 를 찾기<br>
2. obj가 가리키고 있는 값의 주솟값으로 이동 (그림에서는 @6001)<br>
3. 객체의 프로퍼티 값들을 저장하고 있는 메모리(그림에서는 @8123 ~ )로 이동 ▶<br>
a를 찾아서 값을 변경된 메모리 주소로 변경해주기 (@6002 에서 @6005로 변경)<br>

> 💡 여기서 참조형 데이터는 **객체의 프로퍼티 값을 바꿔도 **<br>
**기존 obj의 값은 @6001(주솟값)로 바뀌지 않고 동일함**
>
```
🔎 위에서 기본형 데이터를 변경할 때에는 데이터를 바꿀 때, 가리키고 있는 주소를 직접 바꿔놓았음
```



***

## ✔ 참조 카운트
![](https://velog.velcdn.com/images/doopal2/post/c0c02224-63e0-41b4-ad4e-8be6018bb9a9/image.png)

>위와 같이 배열로 되어있는 프로퍼티 값을 저장할 때에는 마찬가지로 arr의 값을 할당할 메모리 공간 확보 후,<br>
그 주솟값을 arr 데이터의 값에 입력하게 된다.
>
> 이후 `abj.arr = '지두팔'` ▶ 값을 재 할당 하게 되면<br>
원래 참조하고 있던 주솟값을 @6003 ( @9123 ~ ? ) 에서 '지두팔'을 가리키는 주솟값인 @6005로 변경하게 되는데, 그럼 arr의 값도 @6003 에서 @6005로 변경한다.<br>
>

> ❔
원래 8124 에서 6003번을 참조하고 있었는데, <br>
8124의 값이 6005로 변경되며 더이상 6003을 참조하고 있는 대상이 어디에도 없게 되었다.<br>
 **그럼 기존에 있던 6003 ( @9123 ~? ) 의 경우 데이터가 어떻게 될까?**<br>
>> **참조 카운트 : 참조를 하고있는 대상이 몇 개? **<br>
참조 카운트 0 == 6003 을 참조하는 대상이 0개인 상태<br>
👉 이런 메모리는 가비지컬렉터의 수집 대상이 되어서 언젠가 사라지게 됨<br>
>>>👉 6003번이 사라지게 되면서 @9123 ~ ? 도 연쇄적으로 참조카운트가 0이 됨 (같이 가비지 컬렉팅의 대상이 됨)<br>

> **tip**
🎈 obj.x 와 obj.arr[0] 은 값이 같다 (== 123)
 + 값을 직접 저장
   + 데이터 할당 시에는 빠름
   + 비교에는 비용이 많이 듬, 메모리 낭비가 심함
 <br>
 
 + 값의 주소를 저장
   + 데이터 할당 시에는 느림
   + 비교에 비용이 들지 않음 , 메모리 낭비 최소화
     + **같은 값이 전체의 메모리 공간에 오직 하나만 존재** == 불변값
     + so, 그래서 **기본형 데이터가 불변값 이라고 하는 것**
 


***

## ✍ 각 데이터 타입의 값 변경 시 차이점
```javascript
let a = 1;
let b = a;
let obj1 = { 
  c : 1, 
  d: '두팔',
};
let obj2 = obj1;
```
**<메모리>**

|주소|...|1002|1003|1004|1005|...|5002|5003|5004|5005|...|
|---|---|---|---|---|---|---|---|---|---|---|---|
|데이터||이름: a|이름: b|이름: obj1|이름: obj2|...|1|@7103 ~ ?|||...|
|||값: @5002|값: @5002|값: @5003|값: @5003|||||||
<br>

|주소|...|7103|7104|7105|7106|...|
|---|---|---|---|---|---|---|
|데이터||이름: c|이름: d|
|||값: @5002|값: @5006|

<br/>

+ **데이터 값 변경**
```javascript
b = 2;
obj2.c = 5;
```
**<메모리>**

|주소|...|1002|1003|1004|1005|...|5002|5003|5004|5005|...|
|---|---|---|---|---|---|---|---|---|---|---|---|
|데이터||이름: a|이름: b|이름: obj1|이름: obj2|...|1|@7103 ~ ?|2|5|...|
|||값: @5002|값: @5004|값: @5003|값: @5003|||||||
<br>

|주소|...|7103|7104|7105|7106|...|
|---|---|---|---|---|---|---|
|데이터||이름: c|이름: d|
|||값: @5005|값: @5006|
+ ** b=2; 값 변경 이후**
  + **a의 값은 @5002로 동일 **
  + **b의 값은 @5004로 변경됨**
<br>

+ **obj2.c = 5; 프로퍼티의 값 변경 이후**
  + **1004, 1005의 주솟값 모두 @5003로 변경 없이 동일**
  + but, 객체의 **프로퍼티 **c(@7103)**의 값은 @5003 에서 @5005로 바뀜**


> 📝 정리
+ **기본형의 값을 바꿨을 때**에는 / **값이 바로 바뀌는군**. <br>
값을 복사하고 복사한 값을 바꿨는데 ▶ **원본 값은 변함 X, 그대로!**<br>
<br>

+ **참조형의 값을 바꿨을 때**에는 / **여전히 똑같은 객체를 바라보고 있구나**.<br>
객체를 복사하고 복사한 객체 값을 바꿨는데 ▶ **원본 객체의 값이 같이 바뀜!**<br>

<br/>

### 📚 참고자료
***
[강의]
+ [인프런 - 코어 자바스크립트](https://www.inflearn.com/course/%ED%95%B5%EC%8B%AC%EA%B0%9C%EB%85%90-javascript-flow/dashboard)
_해당 강의 수강 후 정리한 내용입니다 :)_